# EGoT-ME
##### Energy Grid of Things - Modeling Environment
##### Sean Keene -  seakeene@pdx.edu
##### Portland State University - Power Engineering Group

# Example Simulation Overview
This simulation overview is taken from the appendices of the Implementation Profile document. Consult the Implementation Profile for more information. 
## Explanation and Configuration
The following section provides a step-by-step example of a single simulation, including preparation, configuration, the mechanisms that occur during a simulation, and the expected output. The simulation parameters are as follows:
* GridAPPS-D Simulation Configuration parameters
  * Start time: 1570041113 (Wed Oct 02 2019 18:31:53 GMT+0000)
  * Duration: 30 (seconds)
  * Model: “_49AD8E07-3BF9-A4E2-CB8F-C3722F837B62” (IEEE 13 node feeder)
* Topology
  * 1:1; i.e. each group represents a single bus, and vice versa.
* DER-Ss active
  * RWHDERS
    * Input files contained in “RWHDERS Inputs” folder.
  * DERSHistoricalDataInput
    * Input file contained in “DERSHistoricalData Inputs” folder.
* Outputs active
  * MCOutputLog
    * Saved to “Logged Grid State Data/MeasOutputLogs.csv”
  * GOOutputInterface
    * Configured to operate with GSP using XML output scheme
    * Saved to “Outputs to DERMS/OutputtoGSP.xml”
* GO Operation
  * MANUAL MODE selected
    * Inputs read from “manually_posted_service_input.xml” in the MC root folder
    * Request 1:
      * `<service1>
       <group_id>1</group_id>
       <service_type>"Energy Schedule"</service_type>
       <interval_start>0</interval_start>
       <interval_duration>0</interval_duration>
       <power>1000</power>
       <ramp>0</ramp>
       <price>0</price>
       <start_time>1570041123</start_time>
         </service1>`

    * Request 2:
      * `<service2>
        <group_id>2</group_id>
        <service_type>"Energy Schedule"</service_type>
      <interval_start>0</interval_start>
      <interval_duration>0</interval_duration>
      <power>1000</power>
      <ramp>0</ramp>
      <price>0</price>
      <start_time>1570041128</start_time>
    </service2>`

* Purpose of simulation
  * Functional test: ensure inputs from DERSHistoricalDataInput are being reflected in the output logs
  * Note: GSP will not be operating during this simulation. Mock inputs showing no effect will be used and outputs to GSP will be ignored. However, the processes will be explained all the same.

## Pre-Simulation Configuration
1. Start GridAPPS-D 
   1. From the command line, navigate to the GridAPPS-D docker container folder and type “./run.sh” to start the container. The most recent version of GridAPPS-D will be downloaded as necessary, along with the updated blazegraph database. 
      1. Important note: Any new version of GridAPPS-D will overwrite the models in the database. The DER-EM addition process will need to be performed after any update. See below for the process to do so.
   2. Within the container, type “./run-gridappsd.sh” to start the GridAPPS-D program.
      1. Note: If necessary, press CTRL-C to exit a running GridAPPS-D program. Type “exit” to leave the gridappsd docker container. Type “./stop.sh -c” to close the docker container.
2. Add DER-EMs to the grid model
   1. Configure the DER addition scripts as follows:
      1. In the DERScripts folder, verify, create or modify and equivalent to “EGoT13_der.txt” with the required number and labelplate info for each DER-EM required as well as the mRID for the proper model.
      2. Verify, modify, or create as needed “EGoT13_orig_der.txt” or an equivalent containing information on any DER that is included in the model by default but should be removed; for example, in the IEEE 13 node feeder, by default the model contains a house and a school, which should be removed.
      3. Modify (or verify) each script within the Initialise_DER_EMs.sh script for the proper feeder model:
         1. drop_orig_der.sh: ensure the proper text file from (ii) is entered.
         2. drop_der.sh: ensure that an equivalent to “EGoT13_der_uuid.txt” is entered. This file contains the DER-EM uuids generated by a previous DER-EM addition script execution; if this is your first time adding DERs to a new model, this file will not yet exist and thus can be ignored.
         3. insert_der.sh: ensure the file from (i) is entered.
         4. drop_all_measurements.sh: uncomment (or, for a new model, add) the line including the mRID for the desired feeder model.
         5. list_all_measurements.sh: uncomment (or, for a new model, add) the line including the mRID for the desired feeder model.
         6. insert_all_measurements.sh: uncomment (or, for a new model, add) lines corresponding to the name of the desired feeder model. If this is the first time adding DER-EMs to a new model, this name is taken from column 4 of the line in list_all_measurements.sh.
   2. Execute the DER-EM addition scripts as follows.
      1. From the MC root folder, execute “Initialise_DER_EMs.bat” or, from the DERScripts folder, execute “Initialise_DER_EMs.sh”. The following steps occur:
         1. drop_orig_der.sh removes “original” DERs from the model; that is, DERs contained in the default models provided by GridAPPS-D, but which the TE wished to be removed by default.
         2. drop_der.sh removes any DER-EMs added to the model by previous DER-EM addition runs. At this point, the model is a “blank slate” containing no DER-EMs.
         3. insert_der.sh adds DER-EMs to the model as listed in EGoT13_der.txt (or equivalent). It also automatically generates uuids for the DER-EMs and places them in the “EGoT13_der_uuid.txt” (or equivalent) file. The model now contains DER-EMs and their controls; however, there are no associated measurement points yet.
         4. drop_all_measurements.sh removes any measurements contained in the files in the Meas folder associated with the selected grid model. As (2) above, this gives us a “blank slate” and prevents duplicate measurement points when the DER-EM addition script is run more than once.
         5. list_all_measurements.sh generates measurement point mRIDs for the selected grid model, collects them in files and adds them to the Meas folder.
         6. insert_all_measurements takes the mRIDs generated in (5) and inserts them into the grid model for the associated DER-EMs. 
   3. At this point, all DER-EMs are added, excess DERs have been removed, and everything in the model has all necessary mRIDs. The grid model is ready for use in the MC; if no GridAPPS-D updates or model modifications are required, this process needs only be run once.
3. Update GridAPPS-D simulation configuration for the simulation parameters (Section B.1.1):
   1. In the Configuration folder, make edits or verify the following in Config.txt:
      1. The Geographical Region, SubGeographicalRegion, and Line mRIDs for the feeder model in use.
      2. start_time
      3. duration
   2. In the Configuration folder, verify or edit topology.xml with the correct topology
      1. For this example, each group should hold a single bus, and each bus should be a member of only one group. An example of the syntax is:
      `<group name= "group-1" >
        <bus name="650" />
      </group>`
4. Configure and enable each DER-S
   1. DERSHistoricalDataInput:
      1. Create an input log. The first column must contain UNIX timestamps. Each pair of columns after this represents the input to a single DER-EM, with the unique identifier being the header of the first column in the pair. For each column pair, the first column must contain Watt values, and the second column must contain the bus the DER should be assigned to (and therefore will be the same value in every row). This log must be saved as a CSV file in the “DERSHistoricalData Inputs” folder.
      2. Modify ModelController.py as follows
         1. DERSHistoricalDataInput class:
            1. Modify or verify that the __init__() method assignment of self.historical_data_file_path attribute is set to the input file (see i.)
         2. MCConfiguration class
            1. Modify or verify that the __init__() method assignment of self.ders_obj_list includes the DERSHistoricalDataInput object by adding or uncommenting the following line in the dictionary:
            `'DERSHistoricalDataInput': 'dersHistoricalDataInput',`
   2. RWHDERS
      1. Create or verify mock input files with the following format:
         1. The filename for each must be “DER#####_Bus$$$.csv” with “#####” representing a 5-digit unique identifier and “$$$” the three-digit bus (locational identifier).
         2. The contents of each must be “P, ####” with P standing for “power” and “####” representing the Watt value of power consumption.
         3. Note: Due to the parameters of this simulation, the GSP will not be active. As such, these files will not change throughout the simulation; the initial values of the mock inputs will be used through the entire simulation. 
      2. Modify ModelController.py as follows
         1. RWHDERS class:
            1. Modify or verify that the __init__() method assignment of self.input_file_path attribute is set to the directory containing the mock  inputs (see i.)
         2. MCConfiguration class
            1. Modify or verify that the __init__() method assignment of self.ders_obj_list includes the RWHDERS object by adding or uncommenting the following line in the dictionary:
            `'RWHDERS': 'rwhDERS'`
5. Configure the GO and outputs
   1. Set GO to MANUAL operation mode:
      1. Modify or verify ModelController.py as follows:
         1. Modify or verify the MCConfiguration.__init__() method self.go_sensor_decision_making_manual_override attribute is set to “True”. 
      2. Ensure a properly formatted “manually_posted_service_input.xml” file exists in the MC root directory
         1. Note: In this simulation, grid service requests will be generated and posted; however, without a GSP to receive them, they’ll simply sit in the “Output to DERMS” directory without being used. Since they’ll still be generated, a proper input file is required.
   2. No configuration is required for the MCOutputLog; the output file name and path can be set by modifying the MCConfiguration.output_log_name attribute.
   3. No configuration is required for the GOOutputInterface; the output file name and path can be set by modifying the GOOutputInterface.send_service_request_messages() method.
6. The MC is now ready. The TE may begin a simulation.

## Simulation execution
1. If not already completed, start GridAPPS-D and configure the system (see section B.1.3)
2. Run the ModelController.py script from an IDE or the command line.
   1. No further inputs should be required for the duration of the simulation. Proper operation should be verified via the terminal.
   2. IMPORTANT NOTE: A glitch in GridAPPS-D causes very frequent instances of GridAPPS-D freezing during the simulation startup process. If the simulation doesn’t seem to be starting in short order, press CTRL-C in the terminal to close GridAPPS-D, type “./run-gridappsd.sh” to re-run the program, and attempt to rerun the ModelController.py script.
3. When the simulation is complete, measurement logs will be generated and placed in the “Logged Grid States Data” directory. These logs can be used to verify DER-EMs operated per the input data sent to DERSHistoricalDataInput. The functional test is complete.

# Simulation Process Summary
The following is a simplified summary of the inner workings and information exchanges of the ME simulation configured in (B.1). This is intended to be a high level overview of operations, and not a full algorithmic description of the system. 

## Simulation Top Level Process
1. The Test Engineer, having previously configured the system, executes “ModelController.py”.
2. Prior to major class instantiation, the MC performs the following tasks:
   1. The “end_program” flag is initialized to “False”.
   2. Python libraries are imported.
   3. Classes and functions are defined.
3. The MC runs “Program Execution”, including the “main loop”:
   1. MCConfiguration is instantiated as a global object.
   2. EDMCore is instantiated as a global object.
   3. The following processes are called:
      1. the EDMCore simulation startup processes (See B.2.1.1)
      2. the callback class instantiation (See B.2.1.2)
   4. The script enters the “main loop.” In this state, all system functions are handled by the callback classes and their respective function calls (See B.2.2). Meanwhile, a while loop verifies that the end_program variable is “False” and, if so, pauses itself briefly. If the end_program variable is set to “True”, quit() is called to end the program.

###EDMCore Simulation Startup Processes
1. edmCore is instantiated
   1. __init__() is called, creating all attributes. No significant processes occur.
2. edmCore.sim_start_up_process() is called.
   1. self.connect_to_gridapps() is called.
      1. A gridappsd library function is called, connecting the MC to the GridAPPS-D program (not simulation) by assigning an object to the self.gapps_session attribute.
   2. self.load_config_from_file() is called.
      1. The GridAPPS-D config parameters are read in and parsed from the Config.txt file.
   3. self.initialize_line_mrid() is called.
      1. The “line” (or model) mRID is parsed from the config and assigned to the proper attribute.
   4. self.establish_mrid_name_lookup_table() is called.
      1. Two queries are sent to the model in the database via the self.gapps_session object. These queries return dictionaries containing the mRID-Name Lookup Table and the CIM Measurement Dictionary for later use by the logger.
   5. self.connect_to_simulation() is called.
      1. This establishes the simulation in GridAPPS-D using the gapps_session object and the config_parameters read in. Generates an object assigned to self.sim_session.
   6. self.initialize_sim_start_time() is called.
      1. The simulation start time attribute is initialized using the start time from the config.
   7. self.initialize_sim_mrid() is called.
      1. Retrieves the mRID for the simulation, called from the self.sim_session object. Places it in the self.sim_mrid attribute.
   8. self.create_objects() is called.
      1. Calls global instances of the following non-callback classes:
         1. MCOutputLog
         2. MCInputInterface
         3. DERSHistoricalDataInput
            1. On construction, sets the DERSHistoricalDataInput.historical_data_file_path attribute based on the MCConfiguration attribute and user configuration.
         4. RWHDERS
            1. On construction, sets the RWHDERS.input_file_path attribute based on the MCConfiguration attribute and user configuration.
         5. DERAssignmentHandler
         6. DERIdentificationManager
         7. GOSensor
         8. GOOutputInterface
   9. self.initialize_all_der_s() is called.
      1. For each DER-S considered “active” (that is, enabled in mcConfiguration), the [object name].intialize_der_s() method of the DER-S is called. This method with this name must be included in every DER-S, customized to its needs, and performs the following:
         1. Connects to or reads in and input data
         2. Using input data, generates a list of DERs to be assigned; each dictionary in said list contains the unique identifier and locational identifier of each DER to be assigned.
   10. derAssignmentHandler.create_assignment_lookup_table() is called.
       1. This queries the model database and produces a list of DER-EMs by locational identifier and mRID.
   11. derAssignmentHandler.assign_all_ders() is called.
       1. This method connects the previous two steps. In the first step, a table of DER Inputs by unique identifier and location was generated; in the second step, a table of DER-EMs by location and mRID was generated. In this step, the assignment handler steps through each DER Input for each DER-S, one by one. For each DER Input, the locational identifier is read, and the assignment handler attempts to locate an unassigned DER-EM on that location. If successful, it returns a dictionary associating the unique identifier with the mRID, which is added to a list: the association table. This continues until the unique identifier of each DER Input is assigned to a DER-EM mRID; or, if not enough DER-EMs exist at the proper location, the system exits with an explicit error informing the TE.
   12. derIdentificationManager.initialize_association_lookup_table() is called.
       1. After the Assignment Manager has completed the assignment task, the association manager is moved to the Identification Manager, which has methods allowing mRIDs to be referenced by unique identifiers and vice versa.
   13. mcOutputLog.set_log_name() is called.
       1. Sets the log name. This method can either assign the attribute directly or be modified to generate custom log names based on system time, for example. Hence the method call.
   14. goSensor.load_manual_service_file() is called.
       1. Loads the XML file containing service requests to be called in Manual Mode.

### Callback Class Instantiation
1. Global function instantiate_callback_classes() is called.
   1. Global callback object edmMeasurementProcessor is instantiated.
   2. Global callback object edmTimekeeper is instantiated.
      1. On construction, the edmTimekeeper.sim_start_time and edmTimekeeper.sim_current_time attributes are set to the start time from the Config.txt file, ensuring that timekeeping starts at the proper time.

## Callback Processes
After the simulation start up processes have been completed, all script functions are handled within the callback classes. EDMTimekeeper handles all functions that are intended to call frequently, and updates once per timestep, or once per second. EDMMeasurementProcessor is dedicated to receiving measurements from the simulation, parsing them into the proper form, and making them available to the GO and logger; it updates less frequently around once per three seconds. 

### On-Timestep Functions
1. Frequently each second, log messages are sent from the GridAPPS-D simulation to the edmTimekeeper object. These messages are sent for many reasons, including errors, system changes, and (internal) simulation timestep incrementation. This invokes edmTimekeeper.on_message(), performing the following tasks.
   1. The GridAPPS-D log message is parsed. If the message indicates that the process is “COMPLETED” or “CLOSED”, self.end_program() is called; this closes out the log file and ends the program. If the log message contains the words “incrementing to”, a timestep has occurred and on-timestep functions are called (see b.) Otherwise, the message is disregarded.
   2. If an incrementation message has been detected, the incrementation method first detects if the log message is a repeat of the last received message. GridAPPS-D often sends the same log message multiple times; this check ensures duplicate messages don’t invoke multiple on-timestep processes or incrementations.
   3. self.increment_sim_current_time() is called.
      1. This increments the edmTimekeeper.sim_current_time by 1.
   4. self.perform_all_on_timestep_updates() is called. This is the encapsulation method that performs all of the system processes that should be done frequently. They include the following:
      1. The edmCore current time is matched to the edmTimekeeper current time.
      2. mcInputInterface.update_all_der_s_status() is called.
         1. This method generates the “unified input request” by calling the [object name].get_input_request() method of each DER-S and appending the results to a list. Said results are a list of dictionaries for each DER-S containing the unique identifiers of DER inputs as keys, and power in Watts as values. These values are taken from the most up-to-date DER inputs and represent the state the DER-EMs should be updated to. In short, the unified input request contains all the DER unique IDs to be updated, and the power values they should be updated to.
      3. mcInputInterface.update_all_der_em_status() is called.
         1. This method reads each line of the unified input request and replaces each unique identifier with the mRID of the DER-EM that DER input has been assigned to (see B.2.1) by referencing the Association Lookup Table in the derIdentificationManager. The result is a new unified input request: this table associates mRIDs with power values. Then, for each item in the unified input request, a message is generated in the proper format containing the target DER-EM mRID and the power; these messages are sent to the EDM via the edmCore.gapps_session object. This causes the DER-EM power values to be adjusted to the new values.
      4. mcOutputLog.update_logs() is called.
         1. If at least one measurement has been parsed by the edmMeasurementProcessor, this method updates the logs. The first time this occurs, the log file is created, the log headers are translated from mRIDs to human-readable names via the mRID-Name Lookup Table in edmCore, the header is written, and a flag is set indicating the logs are ready to be written. If this is not the first measurement, then a line of the logs is written and timestamped using the edmTimekeeper current time.
      5. goSensor.make_service_request_decision() is called.
         1. This method is the same for Automatic and Manual GO operations and uses the configuration flag to determine how to proceed. In this case, Manual mode has been selected; so, it calls the goSensor.manually_post_service() method.
         2. goSensor.manually_post_service() checks the manually_posted_service_input.xml file contents (loaded into a dictionary in the startup process) to see if any services should be posted in the current timestep. If so, it instantiates a GOPostedService object whose attributes are initialized to the values from the input dictionary, and appends the object to the goSensor.posted_service_list to be read by the GOOutputInterface.
      6. goOutputInterface.get_all_posted_service_requests() is called.
         1. The first step in the GO-DERMS communication process. Each goPostedService object on the goSensor.posted_service_list is scanned; if the “status” flag indicates it hasn’t been packaged yet, the service request parameters are pulled from the object attributes and placed in a standardized dictionary. This list of dictionaries is used to generate messages in the next step.
      7. goOutputInterface.send_service_request_messages() is called.
         1. The second and final step in the GO-DERMS communication process. The list of dictionaries in goOutputInterface.current_service_requests is converted to XML format and written to (in this case) an output file to be read by the GSP. In this case, the GSP is inactive so nothing is done with the file; in other simulations, the GSP would read and parse that file to determine when and how to dispatch resources to fulfill the request.

### On-Measurement Functions
1. Once every three seconds, a message is sent from the EDM to the edmMeasurementProcessor object. This message is a very large dictionary of dictionaries containing grid state measurements for every item in the grid model Each measurement is a dictionary containing multiple key/value pairs for mRID, measurement value, measurement angle, etc. Each set of measurements is timestamped, and each measurement is referenced by mRID; however, amplifying data such as readable names, measurement types, phase, bus location, etc. are not included and must be added by the measurement processor. Each measurement message invokes the edmMeasurementProcessor.on_message() method, performing the following tasks:
   1. The message is parsed for the current measurements, which are placed in self.current_measurements.
   2. The message is parsed for the measurement timestamp, which is placed in self.measurement_timestamp.
   3. self.append_names() is called.
      1. This method accesses the MRID-Name Lookup Table and the Measurement Lookup Table from edmCore, and retrieves the measurement mRIDs from the current measurement message. Using those mRIDs, the readable names are pulled from the MRID-Name Lookup Table and added to the individual measurement dictionaries. It then pulls the following values from the Measurement Lookup Table: Measurement Name, Conducting Equipment Name, Bus, Phases, and MeasType and adds these data to the dictionary for each measurement.
   4. self.append_association_data() is called.
      1. This method appends the association data from the derAssignmentHandler lookup table to each measurement; this associates the measurement with the piece of equipment as well as its operating mRID and unique identifiers. This information is useful to reference DER Inputs against resultant grid state changes reflected in the log outputs.
